const express = require("express");
const bcrypt = require("bcryptjs");
const jwt = require('jsonwebtoken');
const User = require("../models/User.js"); // تأكد من المسار الصحيح
const Course = require("../models/Course.js"); // تأكد من المسار الصحيح
const Blog = require('../models/Blog');
const mongoose = require('mongoose');
const fetch = require('node-fetch');


const router = express.Router();

// Google OAuth endpoints
const { OAuth2Client } = require('google-auth-library');
const querystring = require('querystring');

const GOOGLE_CLIENT_ID = process.env.GOOGLE_CLIENT_ID;
const GOOGLE_CLIENT_SECRET = process.env.GOOGLE_CLIENT_SECRET;
const GOOGLE_CALLBACK_URL = process.env.GOOGLE_CALLBACK_URL || 'http://localhost:5000/api/auth/google/callback';
const FRONTEND_BASE_URL = process.env.FRONTEND_BASE_URL || 'http://localhost:5000';

// Facebook OAuth config
const FACEBOOK_CLIENT_ID = process.env.FACEBOOK_CLIENT_ID;
const FACEBOOK_CLIENT_SECRET = process.env.FACEBOOK_CLIENT_SECRET;
const FACEBOOK_CALLBACK_URL = process.env.FACEBOOK_CALLBACK_URL || 'http://localhost:5000/api/auth/facebook/callback';

// Start Google OAuth: redirect to Google's OAuth 2.0 consent screen
router.get('/auth/google', (req, res) => {
    try {
        const scope = [
            'openid',
            'email',
            'profile'
        ];
        const params = {
            client_id: GOOGLE_CLIENT_ID,
            redirect_uri: GOOGLE_CALLBACK_URL,
            response_type: 'code',
            scope: scope.join(' '),
            access_type: 'offline',
            include_granted_scopes: 'true',
            prompt: 'consent'
        };
        // carry state if provided (e.g., state=signup)
        if (req.query && req.query.state) params.state = String(req.query.state);
        const authUrl = 'https://accounts.google.com/o/oauth2/v2/auth?' + querystring.stringify(params);
        return res.redirect(authUrl);
    } catch (err) {
        console.error('Error in /auth/google', err);
        return res.status(500).json({ error: 'Failed to start Google OAuth' });
    }
});

// Google OAuth callback
router.get('/auth/google/callback', async (req, res) => {
    try {
        const code = req.query.code;
        if (!code) return res.status(400).json({ error: 'Missing code' });

        // Exchange code for tokens
        const tokenRes = await fetch('https://oauth2.googleapis.com/token', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: querystring.stringify({
                code,
                client_id: GOOGLE_CLIENT_ID,
                client_secret: GOOGLE_CLIENT_SECRET,
                redirect_uri: GOOGLE_CALLBACK_URL,
                grant_type: 'authorization_code'
            })
        });
        const tokenJson = await tokenRes.json();
        if (!tokenRes.ok) {
            console.error('Google token exchange failed:', tokenJson);
            return res.status(400).json({ error: 'Google token exchange failed', details: tokenJson });
        }
        const idToken = tokenJson.id_token;
        if (!idToken) return res.status(400).json({ error: 'No id_token returned from Google' });

        // Verify id_token
        const oAuth2Client = new OAuth2Client(GOOGLE_CLIENT_ID);
        const ticket = await oAuth2Client.verifyIdToken({ idToken, audience: GOOGLE_CLIENT_ID });
        const payload = ticket.getPayload();
        const googleId = payload.sub;
        const email = payload.email;
        const name = payload.name || email.split('@')[0];
        const picture = payload.picture;
        const emailVerified = !!payload.email_verified;

        if (!email) return res.status(400).json({ error: 'Email missing in Google profile' });

        // Find or create user
        let user = await User.findOne({ $or: [ { provider: 'google', providerId: googleId }, { email } ] });
        if (!user) {
            // create username from email, ensure uniqueness
            let baseUsername = (email.split('@')[0] || 'user').replace(/[^a-zA-Z0-9_\-\.]/g, '').slice(0,20) || 'user';
            let username = baseUsername;
            let i = 1;
            while (await User.findOne({ username })) {
                username = baseUsername + i;
                i++;
            }
            user = new User({
                name: name || username,
                username,
                email,
                password: '',
                provider: 'google',
                providerId: googleId,
                isVerified: emailVerified,
                avatarUrl: picture || ''
            });
            await user.save();
        } else {
            // update provider fields if missing
            let changed = false;
            if (!user.provider || user.provider === 'local') { user.provider = 'google'; changed = true; }
            if (!user.providerId) { user.providerId = googleId; changed = true; }
            if (picture && user.avatarUrl !== picture) { user.avatarUrl = picture; changed = true; }
            if (emailVerified && !user.isVerified) { user.isVerified = true; changed = true; }
            if (changed) await user.save();
        }

        // issue JWT
        const jwtPayload = {
            _id: user._id,
            email: user.email,
            isAdmin: user.isAdmin,
            username: user.username,
            name: user.name,
            picture: user.avatarUrl || picture // Include avatar URL in JWT payload
        };
        const token = jwt.sign(jwtPayload, process.env.JWT_SECRET || 'jwtsecret', { expiresIn: '7d' });

        // redirect to frontend with token and picture URL
        const state = req.query && req.query.state ? String(req.query.state) : '';
        let redirectUrl = FRONTEND_BASE_URL + '/login.html?token=' + encodeURIComponent(token);
        if (picture) {
            redirectUrl += '&picture=' + encodeURIComponent(picture);
        }
        if (state) {
            redirectUrl += '&state=' + encodeURIComponent(state);
        }
        return res.redirect(redirectUrl);
    } catch (err) {
        console.error('Error in /auth/google/callback', err);
        return res.status(500).json({ error: 'Failed to complete Google OAuth' });
    }
});

// Facebook OAuth route
router.get('/auth/facebook', (req, res) => {
    try {
        const params = {
            client_id: FACEBOOK_CLIENT_ID,
            redirect_uri: FACEBOOK_CALLBACK_URL,
            scope: 'email,public_profile',
            response_type: 'code'
        };
        // carry state if provided (e.g., state=signup)
        if (req.query && req.query.state) params.state = String(req.query.state);
        const authUrl = 'https://www.facebook.com/v12.0/dialog/oauth?' + querystring.stringify(params);
        return res.redirect(authUrl);
    } catch (err) {
        console.error('Error in /auth/facebook', err);
        return res.status(500).json({ error: 'Failed to start Facebook OAuth' });
    }
});

// Facebook OAuth callback
router.get('/auth/facebook/callback', async (req, res) => {
    try {
        const code = req.query.code;
        if (!code) return res.status(400).json({ error: 'Missing code' });

        // Exchange code for access token
        const tokenRes = await fetch('https://graph.facebook.com/v12.0/oauth/access_token?' + querystring.stringify({
            client_id: FACEBOOK_CLIENT_ID,
            client_secret: FACEBOOK_CLIENT_SECRET,
            redirect_uri: FACEBOOK_CALLBACK_URL,
            code: code
        }), {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
                client_id: FACEBOOK_CLIENT_ID,
                client_secret: FACEBOOK_CLIENT_SECRET,
                redirect_uri: FACEBOOK_CALLBACK_URL,
                code: code
            })
        });
        const tokenJson = await tokenRes.json();
        if (!tokenRes.ok) {
            console.error('Facebook token exchange failed:', tokenJson);
            return res.status(400).json({ error: 'Facebook token exchange failed', details: tokenJson });
        }

        // Get user profile with access token
        const profileRes = await fetch('https://graph.facebook.com/me?fields=id,name,email,picture', {
            headers: { 'Authorization': 'Bearer ' + tokenJson.access_token }
        });
        const profile = await profileRes.json();
        if (!profileRes.ok) {
            console.error('Failed to fetch Facebook profile:', profile);
            return res.status(400).json({ error: 'Failed to fetch Facebook profile' });
        }

        const facebookId = profile.id;
        const email = profile.email;
        const name = profile.name;
        const picture = profile.picture?.data?.url;

        if (!email) return res.status(400).json({ error: 'Email missing in Facebook profile' });

        // Find or create user
        let user = await User.findOne({ $or: [ { provider: 'facebook', providerId: facebookId }, { email } ] });
        if (!user) {
            // create username from email, ensure uniqueness
            let baseUsername = (email.split('@')[0] || 'user').replace(/[^a-zA-Z0-9_\-\.]/g, '').slice(0,20) || 'user';
            let username = baseUsername;
            let i = 1;
            while (await User.findOne({ username })) {
                username = baseUsername + i;
                i++;
            }
            user = new User({
                name: name || username,
                username,
                email,
                password: '',
                provider: 'facebook',
                providerId: facebookId,
                isVerified: true, // Facebook emails are verified
                avatarUrl: picture || ''
            });
            await user.save();
        } else {
            // update provider fields if missing
            let changed = false;
            if (!user.provider || user.provider === 'local') { user.provider = 'facebook'; changed = true; }
            if (!user.providerId) { user.providerId = facebookId; changed = true; }
            if (picture && user.avatarUrl !== picture) { user.avatarUrl = picture; changed = true; }
            if (!user.isVerified) { user.isVerified = true; changed = true; }
            if (changed) await user.save();
        }

        // issue JWT
        const jwtPayload = {
            _id: user._id,
            email: user.email,
            isAdmin: user.isAdmin,
            username: user.username,
            name: user.name,
            picture: user.avatarUrl || picture
        };
        const token = jwt.sign(jwtPayload, process.env.JWT_SECRET || 'jwtsecret', { expiresIn: '7d' });

        // redirect to frontend with token and picture URL
        const state = req.query && req.query.state ? String(req.query.state) : '';
        let redirectUrl = FRONTEND_BASE_URL + '/login.html?token=' + encodeURIComponent(token);
        if (picture) {
            redirectUrl += '&picture=' + encodeURIComponent(picture);
        }
        if (state) {
            redirectUrl += '&state=' + encodeURIComponent(state);
        }
        return res.redirect(redirectUrl);
    } catch (err) {
        console.error('Error in /auth/facebook/callback', err);
        return res.status(500).json({ error: 'Failed to complete Facebook OAuth' });
    }
});

router.post("/signup", async (req, res) => {
    try {
        const { name, username, email, password, phone } = req.body;
        if (!username || !email || !password) {
            return res.status(400).json({ message: "اسم المستخدم والبريد وكلمة المرور مطلوبة" });
        }

        // تحقق من عدم التكرار في البريد أو اسم المستخدم
        const exist = await User.findOne({ $or: [{ email }, { username }] });
        if (exist) return res.status(400).json({ message: "اسم المستخدم أو البريد الإلكتروني مستخدم بالفعل" });

        const hashedPassword = await bcrypt.hash(password, 10);
        const user = new User({
            name: name || username,
            username,
            email,
            password: hashedPassword,
            phone: phone || ''
        });
        await user.save();

        res.json({ success: true });
    } catch (err) {
        if (err.code === 11000) {
            return res.status(400).json({ message: "اسم المستخدم أو البريد الإلكتروني مستخدم بالفعل" });
        }
        res.status(500).json({ message: "حدث خطأ أثناء إنشاء الحساب" });
    }
});

// routes/auth.js
router.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        const user = await User.findOne({ email });
        if (!user) return res.status(400).json({ message: 'البريد الإلكتروني غير مسجل' });

        const isMatch = await bcrypt.compare(password, user.password);
        if (!isMatch) return res.status(401).json({ message: 'كلمة المرور غير صحيحة' });

        const payload = {
            _id: user._id,
            email: user.email,
            isAdmin: user.isAdmin,
            username: user.username,
            name: user.name
        };
        const token = jwt.sign(payload, process.env.JWT_SECRET || 'jwtsecret', { expiresIn: '7d' });
        res.json({ success: true, user: payload, token });
    } catch (err) {
        console.error('Login error:', err);
        res.status(500).json({ message: 'حدث خطأ في الخادم' });
    }
});

router.get("/user", async (req, res) => {
    const { email } = req.query;
    if (!email) return res.status(400).json({ message: "Email is required" });
    try {
        const user = await User.findOne({ email })
            .select('username email phone name isAdmin isVerified isBlocked created_at avatarUrl provider providerId')
            .lean();
            
        if (!user) return res.status(404).json({ message: "User not found" });
        
        // حذف كلمة المرور والحقول الحساسة من الرد
        delete user.password;
        delete user.__v;
        
        // تأكد من أن الصورة موجودة في الرد
        if (!user.avatarUrl && user.provider === 'google' && user.providerId) {
            // If no avatarUrl but user is from Google, construct Google profile photo URL
            user.avatarUrl = `https://lh3.googleusercontent.com/a/${user.providerId}`;
        }
        
        res.json(user);
    } catch (err) {
        res.status(500).json({ message: "Server error" });
    }
});

// routes/user.js
router.get('/profile', async (req, res) => {
    try {
        const user = await User.findById(req.user.id).select(
            'username email phone name isAdmin isVerified isBlocked created_at'
        );

        if (!user) return res.status(404).json({ error: "User not found" });

        res.json(user);

    } catch (err) {
        res.status(500).json({ error: "Server error" });
    }
});
// تعريف الـ Endpoint
router.get('/api/user', async (req, res) => {
    try {
        const email = req.query.email;

        const user = await User.findOne({ email }).select(
            'username email phone name isAdmin isVerified isBlocked created_at avatarUrl'
        );

        if (!user) return res.status(404).json({ error: "User not found" });

        res.json(user);

    } catch (err) {
        res.status(500).json({ error: "Server error" });
    }
});

// Update user profile (including avatar)
router.put('/users/me/profile', async (req, res) => {
    try {
        // Verify token and get user ID
        const token = req.headers.authorization?.split(' ')[1];
        if (!token) {
            return res.status(401).json({ error: 'Authentication required' });
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET || 'jwtsecret');
        const userId = decoded._id;

        const { avatarUrl } = req.body;
        const updates = {};

        // Only update avatarUrl if provided
        if (avatarUrl) {
            updates.avatarUrl = avatarUrl;
        }

        const user = await User.findByIdAndUpdate(
            userId,
            { $set: updates },
            { new: true }
        ).select('username email phone name isAdmin isVerified avatarUrl');

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        res.json(user);
    } catch (err) {
        if (err.name === 'JsonWebTokenError') {
            return res.status(401).json({ error: 'Invalid token' });
        }
        console.error('Profile update error:', err);
        res.status(500).json({ error: 'Server error' });
    }
});

// جلب جميع المستخدمين - فقط للمسؤولين
router.get('/users', async (req, res) => {
    try {
        const users = await User.find();
        res.json(users);
    } catch (err) {
        res.status(500).json({ error: 'فشل في جلب المستخدمين' });
    }
});


// POST - إنشاء مستخدم جديد
router.post('/users', async (req, res) => {
    try {
        let { username, name, email, password, phone, isAdmin } = req.body;

        // تحويل isAdmin إلى Boolean
        isAdmin = isAdmin === 'on';


        // التحقق من الحقول المطلوبة
        if (!username || !email || !password || !phone || !name || isAdmin) {
            return res.status(400).json({ error: 'الحقول المطلوبة مفقودة' });
        }

        // التحقق من تكرار البريد الإلكتروني
        const existingUser = await User.findOne({ email });
        if (existingUser) {
            return res.status(400).json({ error: 'البريد الإلكتروني مسجل مسبقًا' });
        }

        // تشفير كلمة المرور
        const hashedPassword = await bcrypt.hash(password, 10);

        // إنشاء مستخدم جديد
        const newUser = new User({
            username,
            name,
            email,
            password: hashedPassword,
            phone,
            isAdmin, // تعيين القيمة الافتراضية
        });

        await newUser.save();

        res.status(201).json({
            _id: newUser._id,
            username: newUser.username,
            email: newUser.email,
            name: newUser.name,
            phone: newUser.phone,
            isAdmin: newUser.isAdmin
        });

    } catch (error) {
        console.error('Server Error Details:', error); // سجل الخطأ بالتفصيل
        res.status(500).json({
            error: 'Internal Server Error',
            details: error.message // أرسل تفاصيل الخطأ للعميل
        });
    }
});



// حذف مستخدم
router.delete('/users/:id', async (req, res) => {
    try {
        const user = await User.findByIdAndDelete(req.params.id);

        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        res.json({
            success: true,
            message: 'User deleted successfully'
        });

    } catch (error) {
        console.error('Delete error:', error);
        res.status(500).json({
            success: false,
            error: 'Server error'
        });
    }
});

// تحديث بيانات مستخدم
router.put('/users/:id', async (req, res) => {
    try {
        const updatedUser = await User.findByIdAndUpdate(
            req.params.id,
            req.body,
            { new: true }
        );
        if (!updatedUser) {
            return res.status(404).json({ error: 'المستخدم غير موجود' });
        }
        res.json(updatedUser);
    } catch (err) {
        res.status(500).json({ error: 'خطأ في السيرفر' });
    }
});


router.get('/courses', async (req, res) => {
    console.log('Fetching all courses');
    try {
        const courses = await Course.find();
        res.json({ courses });
    } catch (err) {
        console.error(err);
        res.status(500).json({ error: 'Server Error' });
    }
});


module.exports = router;
